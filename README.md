<h2 align='center'>简单 web ui 自动化测试框架总结</h2>
<p>
  <br>
</p>


用于 web 页面的自动化测试，主要使用 python + selenium + pytest + loguru ，再配合 PageObject 模式搭建。

这是初步学习和使用成果，目的是为了熟悉 ui 自动化测试，并在工作中进行自动化测试，另外也是为了练习 python 编程，拓宽测试技能，提高测试能力。

如果您发现有错误和不足之处，可以在 issue 里留言指出，帮我提升改进，谢谢您的指点！
<p align="center">
<img src="https://img.shields.io/badge/python-3.10.10-brightgreen">
<img src="https://img.shields.io/badge/selenium-4.8.2-orange">
<img src="https://img.shields.io/badge/pytest-7.2.2-blue">
<img src="https://img.shields.io/badge/loguru-0.6.0-blueviolet">
</p>

<p>
  <br>
</p>

## 整体结构

模块划分:
- pageobject 模块: locator_object 、page_object、common 三个包，拆分页面元素和页面操作，封装页面基类，项目各个包和普通文件夹的路径设置等
- 用例模块: test_case、test_data 两个包，包含用例构造，测试数据等
- 工具模块: utils 包，封装日志、js 语句、邮件发送方法等
- 测试输出模块: output 包，存放日志、测试报告

po 分层:
- 基础层（对象库层）: common 包里的 page 模块，封装页面通用的操作、页面属性获取方法等
- 元素层: locator_object 包里的 py 模块用于存放各个页面的元素和定位器信息
- 逻辑层: page_object 包里的 py 模块对应各个页面，py 模块里包含一个页面类，类中封装该页面下的功能操作
- 业务层: 测试用例，实例化逻辑层里的页面类对象，调用封装好的功能操作方法，将一个或多个功能操作组合成一条业务用例

<p>
  <br>
</p>

## 调用关系

page.py 作为 po 模式中的对象库层，是所有页面类的基类，所有的页面类继承自 page.py 里的 Page 类。

页面类继承了这个基类之后，可以调用基类中定义的各种方法，如定位元素、元素等待、输入、点击、断言等方法。

在页面类中，封装前端对应页面中的功能，例如前端有一个登录页面，在框架里就可以定义一个登录页面类。

登录页面中可能有登录、注册、找回密码等等功能点，这些功能点都可以在登录页面类中被封装成方法，方法内部是这些功能的操作步骤。

而操作步骤，是通过调用 Page 这个基类里定义的各种方法而组成。例如现在要在页面类中定义一个登录方法，这个登录方法内部实现登录操作，
登录操作可能要输入账号、密码、验证码等等，所以我们可以在这个登录方法里调用基类里封装的元素输入和元素点击方法，元素输入方法用于给指定的元素输入字符，
元素点击方法用于点击指定的元素，这一个个操作步骤的组合，就完成了一个完整的登录操作。

在登录页面类中定义好了登录方法，我们还需要进一步实现用例的编写，在一个用例文件中，我们可以调用刚刚封装好的登录方法，接下来就要给登录方法传入具体的账号和密码参数。
这时候可以借助 pytest 提供的 `@pytest.mark.parametrize` 装饰器，来完成登录方法的参数化。

参数部分完成之后，我们需要完善登录用例的编写，我们现在只是完成了在测试用例中调用登录方法和实现参数化，用例执行之后，也只是在前端页面上输入和点击相应的元素，执行完毕之后就退出了。

我们不知道执行的结果是不是符合预期，所以我们还需要在用例中添加断言，操作部分执行完毕之后，代码会走到断言部分，如果断言通过，则大体可以表示这条用例通过了、成功了，如果断言失败，就表示失败了。
这样才是一条相对完整的用例。

所以一条相对完整的用例，一定至少要包含两个部分，一是操作、而是断言。

到目前为止，我们说的还是单个功能、单个页面上的测试。如果涉及到多个页面，多个节点的长流程，也是同样的做法，调用多个页面类中封装好的功能方法，放到用例中组合，完成一个长流程测试用例。
例如，现在不光要登录，还要登录之后去购买商品，那么我们可以先从登录页面类中调用登录方法，然后再去商品页面类中调用添加商品方法，接着再调用跳转到结算页面的方法，最后再调用支付页面类中的支付方法，到这里业务流程就结束了，但是我们还需要一个断言来收尾。
所以这条用例最后还要添加一条断言语句。

像这类长流程的测试用例，如果用上面的方法，其实也不是特别适合，一定有更合适的方案来对长流程的测试进行优化，更好的优化代码结构、提高清晰度和效率，关于这一点还需要多学多用，在项目中多思考和总结。

用例执行完成之后，程序还会调用 `pytest-html` 插件来生成测试报告，对于测试结果，也会通过邮件自动发送到项目组中有关同事的邮箱。

以上就是大致的方法调用关系和用例运行过程。

<p>
  <br>
</p>

## 功能实现

### 路径软编码

`directory.py` 里实现了项目各个目录的软编码，使用 python 内置模块 os 实现，一是方便参与自动化测试的同事在 clone 代码之后，不用去特意修改项目的存放路径。
因为使用绝对路径硬编码只是针对于框架编写和维护人员的文件存放习惯，例如 A 同事把这个框架放到 D 盘，其他同事习惯放到 E 盘，路径不一样，框架运行之后，涉及到路径的地方就会报错。

二是因为在框架的其他模块中，也会涉及到路径操作，如果都写成绝对路径，对于维护来说也是比较麻烦的一个点，使用变量来保存路径，在需要使用的地方调用这个路径变量即可，一旦发生改变，我们也只需要修改变量的值即可，而不是在框架里到处去修改。

### Page 基类

`page.py` 封装了所有页面都可能会用到的操作，例如元素等待（线程等待，显示等待、隐式等待）、元素查找、字符输入、点击元素等。

首先在 `__init__` 方法中定义 webdriver 对象，然后在其他方法中，通过这个对象调用 webdriver 提供的各种元素操作 api。

对于异常的捕获，使用 try...except 语句来捕获各个操作可能产生的异常信息，一个操作不管是失败还是成功，都会使用日志模块提供的日志收集器来收集日志，抛出的异常信息也会存到日志里。

在这些方法中，查找元素可能是最基础的方法，也是使用最多的方法，输入字符串需要先通查找定位元素、点击元素也需要先查找和定位元素，也正是因为如此，输入方法和点击方法的内部，可以先调用元素定位方法，然后在对定位到的元素进行输入和点击操作。

这些封装的方法内部，总的来说就说三个部分，一是异常捕获，二是日志，三是元素操作或具体功能的实现。

### 元素模块

将某个页面中的所有需要用到的元素都保存在一个 py 模块里，实现元素和页面操作方法的分离，会更加清晰。

保存在这个模块里的元素不仅仅是元素属性，还包括 selenium 定位器，例如:

```account_input_ele = (By.ID, 'account')```

account_input_ele 保存了前端页面上账号输入框的元素 id `account`，同时又有 `By.ID` 这个 selenium 定位器，我们可以称这个整体为元素对象。

因为 selenium 中 find_element/elements 方法要求我们传入定位器和value（就是元素属性值），所以我们需要传这两个参数，上面的元素对象是一个元组类型，所以在传给 find_element 的时候，我们需要对这个元组类型的参数进行解包，在变量前添加 * 即可：

解包会把元组里的元素拆分，传给 find_element 方法对应的形参。
```
find_element(*account_input_ele)
```

### 页面类

前端每个页面对应代码中的每个页面类，页面类里封装前端对应页面中的功能，例如一个商城后台，它可能包含商品管理页面，我们就可以定义一个商品管理页面类，商品管理包含商品上下架，我们就可以在这个类中封装商品上下架的操作：

另外，每个页面类都要继承 Page 基类。

```
class GoodsManage(Page):
    # 商品上架方法
    def  put_on_shelves(self):
        pass
      
    # 商品下架方法
    def pull_off_shelves(self):
        pass
```

因为继承了 Page 基类，所以我们可以调用 Page 类里的元素操作方法：

```
class GoodsManage(Page):
    # 商品上架方法
    def put_on_shelves(self):
        # 调用基类里的元素操作相关的方法
        self.input()
        self.click()
        ... ...
      
    # 商品下架方法
    def pull_off_shelves(self):
        pass
```

### 测试用例

在测试用例中，通过页面类的对象，来调用页面类里定义的功能操作方法：

```
class TestDemo:
    def test_put_on_shelves(self):
        # 调用封装的功能方法
        GoodsManage().put_on_shelves()
        # 断言
        assert ... == ...
    
    def test_pull_off_shelves(self):
        pass
```

### 日志

python 内置的 `logging` 在配置上相对繁琐，所以我们可以使用第三方库 `loguru` ，这个库使用起来相对简单，我们可以很轻松的就实现日志控制台输出和写入到文件。


### 邮件发送

邮件发送使用 python 内置的 `smtplib` 库。

对于测试结果的发布，我们还可以实现和飞书、钉钉、企业微信等内部办公软件的对接，接入它们提供的机器人，通过机器人发送测试结果给指定的人或者工作群。

发送的内容可以带上 html 测试报告的存放地址（有些公司内部可能会放到服务器中）


### js 交互

在 web 端 ui 自动化测试过程中，我们可能需要使用 js 来完成某些操作，selenium 提供了 `execute_script()` 方法来执行 js 语句，我们只需要传入 js 语句即可。

在 utils 包里有一个 js.py 模块，里面封装了在 ui 自动化中常用的一些 js 语句，使用时，只需要调用对应的函数，这些函数会返回 js 语句。

### conftest 

`conftest.py` 是 pytest 中一个特殊的文件，在程序执行的时候，pytest 会自动去调用这个文件，可以在里面定义一些 fixture 或钩子函数，为测试框架拓展一些功能。

在项目根目录下的 conftest.py 文件里，我们可以实现钩子函数 `pytest_addoption` 用来添加自定义的命令行参数，例如指定在哪个浏览器运行，我们可以定义一个参数名叫 `--browser` ，默认值是谷歌 chrome 浏览器，
在使用 pytest 命令执行测试用例时，我们可以带上这个参数，例如：

```shell
pytest --browser firfox
```

这个命令会在 firfox 火狐浏览器上运行测试。

在 test_case 测试用例包中，我们也可以创建一个 conftest.py 文件，在这个文件中，我们实现一个初始化 webdriver 对象的函数。
接收第一个 conftest.py 里定义的 `--browser` 参数的值，通过对这个值做判断来返回对应的浏览器 webdriver 对象。



<p align="center">功能实现部分只是简单概括，详情可以进入相应的文件中查看源码</p>

<p>
  <br>
</p>

